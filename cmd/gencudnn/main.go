package main

import (
	"fmt"
	"log"
	"os/exec"
	"strings"

	"os"
	"path"

	"github.com/cznic/cc"
	"github.com/gorgonia/bindgen"
)

var pkgloc string
var apiFile string
var ctxFile string
var hdrfile string
var pkghdr string
var model = bindgen.Model()

func init() {
	gopath := os.Getenv("GOPATH")
	pkgloc = path.Join(gopath, "src/gorgonia.org/cu/dnn")
	apiFile = path.Join(pkgloc, "api.go")
	ctxFile = path.Join(pkgloc, "ctx_api.go")
	hdrfile = "cudnn.h"

	pkghdr = `package cudnn

/* Generated by gencudnn. DO NOT EDIT */

// #include <cudnn_v7.h>
import "C"
`
}

func handleErr(err error) {
	if err != nil {
		panic(err)
	}
}

// yes I know goimports can be imported, but I'm lazy
func goimports(filename string) error {
	cmd := exec.Command("goimports", "-w", filename)
	return cmd.Run()
}

func main() {
	// Step 1: Explore
	// explore(hdrfile, functions, enums, otherTypes)
	// explore(hdrfile, otherTypes)
	// Step 2: generate mappings for this package, then edit them manually
	// 	Specifically, the `ignored` map is edited - things that will be manually written are not removed from the list
	//	Some enum map names may also be changed
	// generateMappings(true)

	// Step 3: generate enums, then edit the file in the dnn package.
	// generateEnums()
	generateStubs()

}

func explore(file string, things ...bindgen.FilterFunc) {
	t, err := bindgen.Parse(model, file)
	handleErr(err)
	bindgen.Explore(t, things...)
}

func generateEnums() {
	buf, err := os.OpenFile(path.Join(pkgloc, "enums.go"), os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644)
	handleErr(err)
	defer buf.Close()
	fmt.Fprintln(buf, pkghdr)

	t, err := bindgen.Parse(model, hdrfile)
	handleErr(err)

	decls, err := bindgen.Get(t, enums)
	handleErr(err)

	for _, d := range decls {
		e := d.(*bindgen.Enum)
		if isIgnored(e.Name) {
			continue
		}
		fmt.Fprintf(buf, "type %v int\nconst (\n", enumMappings[e.Name])

		var names []string
		for _, a := range e.Type.EnumeratorList() {
			cname := string(a.DefTok.S())
			names = append(names, cname)
		}

		lcp := bindgen.LongestCommonPrefix(names...)

		for _, a := range e.Type.EnumeratorList() {
			cname := string(a.DefTok.S())
			enumName := processEnumName(lcp, cname)
			fmt.Fprintf(buf, "%v %v = C.%v\n", enumName, enumMappings[e.Name], cname)
		}
		fmt.Fprint(buf, ")\n")
		fmt.Fprintf(buf, "func (e %v) c() C.%v { return C.%v(e) }\n", enumMappings[e.Name], e.Name, e.Name)
	}
}

func generateStubs() {
	t, err := bindgen.Parse(model, hdrfile)
	handleErr(err)
	filename := "FOO.go"
	fullpath := path.Join(pkgloc, filename)
	buf, err := os.OpenFile(fullpath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
	fmt.Fprintln(buf, pkghdr)
	for k, v := range creations {
		if isIgnored(v) || v == "" {
			continue
		}
		gotype, ok := ctypes2GoTypes[k]
		if !ok {
			log.Printf("Cnanot generate for %q", k)
			continue
		}
		// filename := "generated" + gotype + ".go"
		// filename = "FOO.go"
		// fullpath := path.Join(pkgloc, filename)
		// buf, err := os.OpenFile(fullpath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
		handleErr(err)

		// fmt.Fprintln(buf, pkghdr)

		// get the creation function to "guess" what should be in the struct
		filter := func(decl *cc.Declarator) bool {
			if decl.Type.Kind() != cc.Function {
				return false
			}
			if bindgen.NameOf(decl) == v {
				return true
			}
			return false
		}
		decls, err := bindgen.Get(t, filter)
		handleErr(err)

		cs := decls[0].(*bindgen.CSignature)
		sig := GoSignature{}
		body := Con{
			Ctype:  k,
			GoType: gotype,
			Create: strings.Replace(v, "Set", "Create", -1),
			Set:    v,
		}

		params := cs.Parameters()
		retValPos := retVals[cs.Name]
		for i, p := range params {
			if _, ok := retValPos[i]; ok {
				continue
			}
			typName := goNameOf(p.Type())
			if typName == gotype || typName == "" {
				log.Printf("%q: Parameter %d Skipped %q of %v", cs.Name, i, p.Name(), typName)
				continue
			}

			sig.Params = append(sig.Params, Param{Name: p.Name(), Type: reqPtr(typName)})
			body.Params = append(body.Params, p.Name())
			body.ParamType = append(body.ParamType, typName)
		}
		sig.Name = fmt.Sprintf("New%v", gotype)
		sig.RetVals = []Param{
			{Type: "*" + gotype},
			{Type: "error"},
		}
		constructStructTemplate.Execute(buf, body)

		fmt.Fprintf(buf, "\n%v{ \n", sig)
		constructionTemplate.Execute(buf, body)
		fmt.Fprintf(buf, "}\n")

	}
	buf.Close()
	if err := goimports(fullpath); err != nil {
		log.Printf("Failed to Goimports %q: %v", fullpath, err)
	}

}

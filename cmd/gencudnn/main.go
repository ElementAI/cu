package main

import (
	"fmt"
	"io"
	"log"
	"os/exec"
	"strings"

	"os"
	"path"

	"github.com/cznic/cc"
	"github.com/gorgonia/bindgen"
)

var pkgloc string
var apiFile string
var ctxFile string
var hdrfile string
var pkghdr string
var model = bindgen.Model()

func init() {
	gopath := os.Getenv("GOPATH")
	pkgloc = path.Join(gopath, "src/gorgonia.org/cu/dnn")
	apiFile = path.Join(pkgloc, "api.go")
	ctxFile = path.Join(pkgloc, "ctx_api.go")
	hdrfile = "cudnn.h"

	pkghdr = `package cudnn

/* Generated by gencudnn. DO NOT EDIT */

// #include <cudnn_v7.h>
import "C"
`

}

func handleErr(err error) {
	if err != nil {
		panic(err)
	}
}

// yes I know goimports can be imported, but I'm lazy
func goimports(filename string) error {
	cmd := exec.Command("goimports", "-w", filename)
	return cmd.Run()
}

func main() {
	// Step 1: Explore
	// explore(hdrfile, functions, enums, otherTypes)
	// explore(hdrfile, otherTypes)
	// explore(hdrfile, functions)

	// Step 2: generate mappings for this package, then edit them manually
	// 	Specifically, the `ignored` map is edited - things that will be manually written are not removed from the list
	//	Some enum map names may also be changed
	// generateMappings(true)

	// Step 3: generate enums, then edit the file in the dnn package.
	// generateEnums()
	// generateStubs(true)

	// Step 3a: run parse.py to get more sanity

	// Step 4: manual fix for inconsistent names (Spatial Transforms)

	// step 5:
	generateFunctions()

	// report things that aren't done yet
	reportTODOs(hdrfile, otherTypes, enums, functions)
}

func explore(file string, things ...bindgen.FilterFunc) {
	t, err := bindgen.Parse(model, file)
	handleErr(err)
	bindgen.Explore(t, things...)
}

func reportTODOs(file string, things ...bindgen.FilterFunc) {
	// track what's been generated
	for k := range enumMappings {
		generated[k] = struct{}{}
	}
	for k, v := range creations {
		generated[k] = struct{}{}
		for _, fn := range v {
			generated[fn] = struct{}{}
		}
	}
	for k, v := range setFns {
		generated[k] = struct{}{}
		for _, fn := range v {
			generated[fn] = struct{}{}
		}
	}
	for k, v := range destructions {
		generated[k] = struct{}{}
		for _, fn := range v {
			generated[fn] = struct{}{}
		}
	}
	for _, v := range methods {
		for _, fn := range v {
			generated[fn] = struct{}{}
		}
	}

	t, err := bindgen.Parse(bindgen.Model(), file)
	handleErr(err)
	for _, thing := range things {
		decls, err := bindgen.Get(t, thing)
		handleErr(err)
		for _, decl := range decls {
			name := bindgen.NameOf(decl)
			_, ignored := ignored[name]
			if _, ok := generated[name]; !ok && !ignored {
				fmt.Printf("%q not generated yet\n", name)
			}
		}
	}
}

func generateEnums() {
	fullpath := path.Join(pkgloc, "enums.go")
	buf, err := os.OpenFile(fullpath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644)
	handleErr(err)
	fmt.Fprintln(buf, pkghdr)

	t, err := bindgen.Parse(model, hdrfile)
	handleErr(err)

	decls, err := bindgen.Get(t, enums)
	handleErr(err)

	for _, d := range decls {
		e := d.(*bindgen.Enum)
		if isIgnored(e.Name) {
			continue
		}
		fmt.Fprintf(buf, "type %v int\nconst (\n", enumMappings[e.Name])

		var names []string
		for _, a := range e.Type.EnumeratorList() {
			cname := string(a.DefTok.S())
			names = append(names, cname)
		}

		lcp := bindgen.LongestCommonPrefix(names...)

		for _, a := range e.Type.EnumeratorList() {
			cname := string(a.DefTok.S())
			enumName := processEnumName(lcp, cname)
			fmt.Fprintf(buf, "%v %v = C.%v\n", enumName, enumMappings[e.Name], cname)
		}
		fmt.Fprint(buf, ")\n")
		fmt.Fprintf(buf, "func (e %v) c() C.%v { return C.%v(e) }\n", enumMappings[e.Name], e.Name, e.Name)
	}
	buf.Close()
	if err := goimports(fullpath); err != nil {
		log.Printf("Failed to Goimports %q: %v", fullpath, err)
	}
}

// generateStubs creates most of the stubs
func generateStubs(debugMode bool) {
	t, err := bindgen.Parse(model, hdrfile)
	handleErr(err)
	var buf io.WriteCloser
	var fullpath string
	if debugMode {
		filename := "FOO.go"
		fullpath = path.Join(pkgloc, filename)
		buf, err = os.OpenFile(fullpath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644)
		handleErr(err)
		fmt.Fprintln(buf, pkghdr)
	}

	var todoCount int
outer:
	for k, vs := range setFns {
		var hasTODO bool
		gotype, ok := ctypes2GoTypes[k]
		if !ok {
			log.Printf("Cannot generate for %q", k)
			continue
		}
		// if we're not in debugging mode, then we should write out to different files per type generated
		// this makes it easier to work on all the TODOs
		if !debugMode {
			filename := gotype + "_gen.go"
			fullpath = path.Join(pkgloc, filename)
			buf, err = os.OpenFile(fullpath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644)
			handleErr(err)
			fmt.Fprintln(buf, pkghdr)
		}

		for _, v := range vs {
			if isIgnored(v) {
				log.Printf("Skipped generating for %q", k)
				continue outer
			}
		}

		// get the creation function to "guess" what should be in the struct
		filter := func(decl *cc.Declarator) bool {
			if decl.Type.Kind() != cc.Function {
				return false
			}
			n := bindgen.NameOf(decl)
			for _, v := range vs {
				if n == v {
					return true
				}
			}
			return false
		}
		decls, err := bindgen.Get(t, filter)
		handleErr(err)

		cs := decls[0].(*bindgen.CSignature)
		sig := GoSignature{}
		var create, destroy string
		if creates, ok := creations[k]; ok {
			create = creates[0]
		}
		if destroys, ok := destructions[k]; ok {
			destroy = destroys[0]
		}

		if create == "" || destroy == "" {
			log.Printf("Skipped %v - No Create/Destroy", k)
			continue
		}

		body := Con{
			Ctype:   k,
			GoType:  gotype,
			Create:  create,
			Destroy: destroy,
			Set:     vs,
		}
		sig.Receiver = Param{Type: gotype}

		if _, err = csig2gosig(cs, "*"+gotype, true, &sig); err != nil {
			body.TODO = err.Error()
			log.Print(body.TODO)
			hasTODO = true
		}
		for _, p := range sig.Params {
			body.Params = append(body.Params, p.Name)
			body.ParamType = append(body.ParamType, p.Type)
		}

		sig.Name = fmt.Sprintf("New%v", gotype)
		sig.Receiver = Param{} // Param is set to empty
		constructStructTemplate.Execute(buf, body)

		fmt.Fprintf(buf, "\n%v{ \n", sig)
		if len(vs) > 1 {
			hasTODO = true
			constructionTODOTemplate.Execute(buf, body)
		} else {
			constructionTemplate.Execute(buf, body)
		}
		fmt.Fprintf(buf, "}\n")

		// getters
		retValPos := getRetVal(cs)
		if len(vs) > 1 {
			fmt.Fprintf(buf, "// TODO: Getters for %v\n", gotype)
			goto generateDestructor
		}
		for i, p := range cs.Parameters() {
			if _, ok := retValPos[i]; ok {
				continue
			}
			getterSig := GoSignature{}
			typName := goNameOf(p.Type())

			// receiver - we don;t log - adds to the noise
			if typName == gotype {
				continue
			}

			if typName == "" {
				hasTODO = true
				fmt.Fprintf(buf, "//TODO: %q: Parameter %d Skipped %q of %v - unmapped type\n", cs.Name, i, p.Name(), p.Type())
				continue
			}

			getterSig.Receiver.Name = strings.ToLower(string(gotype[0]))
			getterSig.Receiver.Type = "*" + gotype
			getterSig.Name = strings.Title(p.Name())
			getterSig.RetVals = []Param{{Type: typName}}
			fmt.Fprintf(buf, "\n%v{ return %v.%v }\n", getterSig, getterSig.Receiver.Name, p.Name())
		}

	generateDestructor:
		// destructor
		destructor := GoSignature{}
		destructor.Name = "destroy" + gotype
		destructor.Params = []Param{
			{Name: "obj", Type: gotype, IsPtr: true},
		}
		fmt.Fprintf(buf, "\n%v{", destructor)
		destructTemplate.Execute(buf, body)
		fmt.Fprintf(buf, "}\n")

		if !debugMode {
			buf.Close()
			if err := goimports(fullpath); err != nil {
				log.Printf("Failed to Goimports %q: %v", fullpath, err)
			}
		}
		if hasTODO {
			todoCount++
		}
	}
	log.Printf("%d/%d TODOs", todoCount, len(setFns))

	buf.Close()
	if err := goimports(fullpath); err != nil {
		log.Printf("Failed to Goimports %q: %v", fullpath, err)
	}
}

func generateFunctions() {
	t, err := bindgen.Parse(model, hdrfile)
	handleErr(err)
	filename := "FOO2.go"
	fullpath := path.Join(pkgloc, filename)
	buf, err := os.OpenFile(fullpath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644)
	fmt.Fprintln(buf, pkghdr)
	decls, err := bindgen.Get(t, functions)
	handleErr(err)

	for rec, fns := range methods {
		var todoCount int
		for _, decl := range decls {
			csig := decl.(*bindgen.CSignature)
			name := csig.Name
			if !inList(name, fns) {
				continue
			}
			if _, ok := ignored[name]; ok {
				continue
			}
			sig := GoSignature{}
			sig.Receiver.Name = string(rec[0])
			sig.Receiver.Type = reqPtr(goNameOfStr(rec))
			sig.Name = fnNameMap[name]

			csig2gosig(csig, "", true, &sig)

			fmt.Fprintf(buf, "%v { \n", sig)
			ab := sig.AlphaBetas()
			if len(ab) > 0 {
				check := sig.FirstTensor()
				if check == "" {
					panic(fmt.Sprintf("No tensors to check: %v", sig))
				}
				data := AlphaBeta{
					Params:      ab,
					Check:       check,
					LSO:         len(ab) - 1,
					MultiReturn: len(sig.RetVals) > 1,
				}
				alphaTemplate.Execute(buf, data)
			}

			// update tracking matrix
			// the goal is to find out which parameter has not been coverted yet
			cparams := csig.Parameters()
			track := make([]bool, len(cparams))

			// receiver
			var receiverParam string
			for i, p := range cparams {
				if goNameOf(p.Type()) == sig.Receiver.Type {
					track[i] = true
					receiverParam = p.Name()
					break // only ONE receiver
				}
			}

			// alpha/betas
			for _, a := range ab {
				for i, p := range cparams {
					if p.Name() == a {
						track[i] = true
					}
				}
			}

			// other params
			for _, p := range sig.Params {
				for i, cp := range cparams {
					if cp.Name() == p.Name {
						track[i] = true
					}
				}
			}

			var hasTodo bool
			for i, t := range track {
				if !t {
					fmt.Fprintf(buf, "// TODO: %v %v\n", cparams[i].Name(), nameOfType(cparams[i].Type()))
					hasTodo = true
				}
			}
			if hasTodo {
				todoCount++
			}

			// make the call
			callParams := make([]Param, len(cparams))
			for i, p := range cparams {
				pname := p.Name()
				callParams[i].Type = goNameOf(p.Type())
				callParams[i].Name = pname
				if inList(pname, alphaBetaParams) {
					callParams[i].Name += "C"
				}
				if pname == receiverParam {
					callParams[i].Name = sig.Receiver.Name
				}

			}
			data := Call{
				Params:      callParams,
				CFuncName:   csig.Name,
				MultiReturn: len(sig.RetVals) > 1,
			}
			callTemplate.Execute(buf, data)
			fmt.Fprintf(buf, "}\n")
		}
		log.Printf("Receiver : %v. Functions: %d. TODOs: %d", rec, len(fns), todoCount)
	}
	buf.Close()
	if err := goimports(fullpath); err != nil {
		log.Printf("Failed to Goimports %q: %v", fullpath, err)
	}
}

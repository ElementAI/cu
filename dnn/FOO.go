package cudnn

/* Generated by gencudnn. DO NOT EDIT */

// #include <cudnn_v7.h>
import "C"
import "runtime"

type Reduction struct {
	internal C.cudnnReduceTensorDescriptor_t

	reduceTensorOp          ReduceTensorOp
	reduceTensorCompType    DataType
	reduceTensorNanOpt      NanPropagation
	reduceTensorIndices     ReduceTensorIndices
	reduceTensorIndicesType IndicesType
}

func NewReduction(reduceTensorOp ReduceTensorOp, reduceTensorCompType DataType, reduceTensorNanOpt NanPropagation, reduceTensorIndices ReduceTensorIndices, reduceTensorIndicesType IndicesType) (*Reduction, error) {
	var internal C.cudnnReduceTensorDescriptor_t
	if err := result(C.cudnnCreateReduceTensorDescriptor(&internal)); err != nil {
		return nil, err
	}

	if err := result(C.cudnnSetReduceTensorDescriptor(internal, reduceTensorOp.c(), reduceTensorCompType.c(), reduceTensorNanOpt.c(), reduceTensorIndices.c(), reduceTensorIndicesType.c())); err != nil {
		return nil, err
	}

	retVal := &Reduction{
		internal:                internal,
		reduceTensorOp:          reduceTensorOp,
		reduceTensorCompType:    reduceTensorCompType,
		reduceTensorNanOpt:      reduceTensorNanOpt,
		reduceTensorIndices:     reduceTensorIndices,
		reduceTensorIndicesType: reduceTensorIndicesType,
	}
	runtime.SetFinalizer(retVal, destroyReduction)
	return retVal, nil
}

func (R *Reduction) ReduceTensorOp() ReduceTensorOp { return R.reduceTensorOp }

func (R *Reduction) ReduceTensorCompType() DataType { return R.reduceTensorCompType }

func (R *Reduction) ReduceTensorNanOpt() NanPropagation { return R.reduceTensorNanOpt }

func (R *Reduction) ReduceTensorIndices() ReduceTensorIndices { return R.reduceTensorIndices }

func (R *Reduction) ReduceTensorIndicesType() IndicesType { return R.reduceTensorIndicesType }

func destoryReduction(obj Reduction) { C.cudnnDestroyReduceTensorDescriptor(obj.internal) }

type LRN struct {
	internal C.cudnnLRNDescriptor_t

	lrnN     uint
	lrnAlpha float64
	lrnBeta  float64
	lrnK     float64
}

func NewLRN(lrnN uint, lrnAlpha float64, lrnBeta float64, lrnK float64) (*LRN, error) {
	var internal C.cudnnLRNDescriptor_t
	if err := result(C.cudnnCreateLRNDescriptor(&internal)); err != nil {
		return nil, err
	}

	if err := result(C.cudnnSetLRNDescriptor(internal, C.uint(lrnN), C.double(lrnAlpha), C.double(lrnBeta), C.double(lrnK))); err != nil {
		return nil, err
	}

	retVal := &LRN{
		internal: internal,
		lrnN:     lrnN,
		lrnAlpha: lrnAlpha,
		lrnBeta:  lrnBeta,
		lrnK:     lrnK,
	}
	runtime.SetFinalizer(retVal, destroyLRN)
	return retVal, nil
}

func (L *LRN) LrnN() uint { return L.lrnN }

func (L *LRN) LrnAlpha() float64 { return L.lrnAlpha }

func (L *LRN) LrnBeta() float64 { return L.lrnBeta }

func (L *LRN) LrnK() float64 { return L.lrnK }

func destoryLRN(obj LRN) { C.cudnnDestroyLRNDescriptor(obj.internal) }

type Dropout struct {
	internal C.cudnnDropoutDescriptor_t

	handle  Context
	dropout float32
	seed    uint64
}

func NewDropout(handle *Context, dropout float32, seed uint64) (*Dropout, error) {
	var internal C.cudnnDropoutDescriptor_t
	if err := result(C.cudnnCreateDropoutDescriptor(&internal)); err != nil {
		return nil, err
	}

	if err := result(C.cudnnSetDropoutDescriptor(internal, handle.internal, C.float(dropout), C.uint64(seed))); err != nil {
		return nil, err
	}

	retVal := &Dropout{
		internal: internal,
		handle:   handle,
		dropout:  dropout,
		seed:     seed,
	}
	runtime.SetFinalizer(retVal, destroyDropout)
	return retVal, nil
}

func (D *Dropout) Handle() Context { return D.handle }

func (D *Dropout) Dropout() float32 { return D.dropout }

func (D *Dropout) Seed() uint64 { return D.seed }

func destoryDropout(obj Dropout) { C.cudnnDestroyDropoutDescriptor(obj.internal) }

type RNN struct {
	internal C.cudnnRNNDescriptor_t

	handle      Context
	hiddenSize  int
	numLayers   int
	dropoutDesc Dropout
	inputMode   RNNInputMode
	direction   DirectionMode
	mode        RNNMode
	algo        RNNAlgo
	dataType    DataType
}

func NewRNN(handle *Context, hiddenSize int, numLayers int, dropoutDesc *Dropout, inputMode RNNInputMode, direction DirectionMode, mode RNNMode, algo RNNAlgo, dataType DataType) (*RNN, error) {
	var internal C.cudnnRNNDescriptor_t
	if err := result(C.cudnnCreateRNNDescriptor(&internal)); err != nil {
		return nil, err
	}

	if err := result(C.cudnnSetRNNDescriptor(internal, handle.internal, C.int(hiddenSize), C.int(numLayers), dropoutDesc.internal, inputMode.c(), direction.c(), mode.c(), algo.c(), dataType.c())); err != nil {
		return nil, err
	}

	retVal := &RNN{
		internal:    internal,
		handle:      handle,
		hiddenSize:  hiddenSize,
		numLayers:   numLayers,
		dropoutDesc: dropoutDesc,
		inputMode:   inputMode,
		direction:   direction,
		mode:        mode,
		algo:        algo,
		dataType:    dataType,
	}
	runtime.SetFinalizer(retVal, destroyRNN)
	return retVal, nil
}

func (R *RNN) Handle() Context { return R.handle }

func (R *RNN) HiddenSize() int { return R.hiddenSize }

func (R *RNN) NumLayers() int { return R.numLayers }

func (R *RNN) DropoutDesc() Dropout { return R.dropoutDesc }

func (R *RNN) InputMode() RNNInputMode { return R.inputMode }

func (R *RNN) Direction() DirectionMode { return R.direction }

func (R *RNN) Mode() RNNMode { return R.mode }

func (R *RNN) Algo() RNNAlgo { return R.algo }

func (R *RNN) DataType() DataType { return R.dataType }

func destoryRNN(obj RNN) { C.cudnnDestroyRNNDescriptor(obj.internal) }

type PersistentRNNPlan struct {
	internal C.cudnnPersistentRNNPlan_t

	rnnDesc RNN
}

func NewPersistentRNNPlan(rnnDesc *RNN) (*PersistentRNNPlan, error) {
	var internal C.cudnnPersistentRNNPlan_t
	if err := result(C.cudnnCreatePersistentRNNPlan(&internal)); err != nil {
		return nil, err
	}

	if err := result(C.cudnnSetPersistentRNNPlan(internal, rnnDesc.internal)); err != nil {
		return nil, err
	}

	retVal := &PersistentRNNPlan{
		internal: internal,
		rnnDesc:  rnnDesc,
	}
	runtime.SetFinalizer(retVal, destroyPersistentRNNPlan)
	return retVal, nil
}

func (P *PersistentRNNPlan) RnnDesc() RNN { return P.rnnDesc }

func destoryPersistentRNNPlan(obj PersistentRNNPlan) { C.cudnnDestroyPersistentRNNPlan(obj.internal) }

type SpatialTransformer struct {
	internal C.cudnnSpatialTransformerDescriptor_t

	samplerType SamplerType
	dataType    DataType
	nbDims      int
}

func NewSpatialTransformer(samplerType SamplerType, dataType DataType, nbDims int) (*SpatialTransformer, error) {
	var internal C.cudnnSpatialTransformerDescriptor_t
	if err := result(C.cudnnCreateSpatialTransformerNdDescriptor(&internal)); err != nil {
		return nil, err
	}

	if err := result(C.cudnnSetSpatialTransformerNdDescriptor(internal, samplerType.c(), dataType.c(), C.int(nbDims))); err != nil {
		return nil, err
	}

	retVal := &SpatialTransformer{
		internal:    internal,
		samplerType: samplerType,
		dataType:    dataType,
		nbDims:      nbDims,
	}
	runtime.SetFinalizer(retVal, destroySpatialTransformer)
	return retVal, nil
}

func (S *SpatialTransformer) SamplerType() SamplerType { return S.samplerType }

func (S *SpatialTransformer) DataType() DataType { return S.dataType }

func (S *SpatialTransformer) NbDims() int { return S.nbDims }

func destorySpatialTransformer(obj SpatialTransformer) {
	C.cudnnDestroySpatialTransformerNdDescriptor(obj.internal)
}

type Activation struct {
	internal C.cudnnActivationDescriptor_t

	mode       ActivationMode
	reluNanOpt NanPropagation
	coef       float64
}

func NewActivation(mode ActivationMode, reluNanOpt NanPropagation, coef float64) (*Activation, error) {
	var internal C.cudnnActivationDescriptor_t
	if err := result(C.cudnnCreateActivationDescriptor(&internal)); err != nil {
		return nil, err
	}

	if err := result(C.cudnnSetActivationDescriptor(internal, mode.c(), reluNanOpt.c(), C.double(coef))); err != nil {
		return nil, err
	}

	retVal := &Activation{
		internal:   internal,
		mode:       mode,
		reluNanOpt: reluNanOpt,
		coef:       coef,
	}
	runtime.SetFinalizer(retVal, destroyActivation)
	return retVal, nil
}

func (A *Activation) Mode() ActivationMode { return A.mode }

func (A *Activation) ReluNanOpt() NanPropagation { return A.reluNanOpt }

func (A *Activation) Coef() float64 { return A.coef }

func destoryActivation(obj Activation) { C.cudnnDestroyActivationDescriptor(obj.internal) }

type CTCLoss struct {
	internal C.cudnnCTCLossDescriptor_t

	compType DataType
}

func NewCTCLoss(compType DataType) (*CTCLoss, error) {
	var internal C.cudnnCTCLossDescriptor_t
	if err := result(C.cudnnCreateCTCLossDescriptor(&internal)); err != nil {
		return nil, err
	}

	if err := result(C.cudnnSetCTCLossDescriptor(internal, compType.c())); err != nil {
		return nil, err
	}

	retVal := &CTCLoss{
		internal: internal,
		compType: compType,
	}
	runtime.SetFinalizer(retVal, destroyCTCLoss)
	return retVal, nil
}

func (C *CTCLoss) CompType() DataType { return C.compType }

func destoryCTCLoss(obj CTCLoss) { C.cudnnDestroyCTCLossDescriptor(obj.internal) }

package cudnn

/* Generated by gencudnn. DO NOT EDIT */

// #include <cudnn_v7.h>
import "C"

type RNN struct {
	internal C.cudnnRNNDescriptor_t

	handle      Context
	rnnDesc     RNN
	hiddenSize  int
	numLayers   int
	dropoutDesc Dropout
	inputMode   RNNInputMode
	direction   DirectionMode
	mode        RNNMode
	algo        RNNAlgo
	dataType    DataType
}

func NewRNN(handle Context, rnnDesc RNN, hiddenSize int, numLayers int, dropoutDesc Dropout, inputMode RNNInputMode, direction DirectionMode, mode RNNMode, algo RNNAlgo, dataType DataType) (*RNN, error) {
	var internal C.cudnnRNNDescriptor_t
	if err := result(C.cudnnCreateRNNDescriptor(&internal)); err != nil {
		return nil, err
	}

	if err := result(C.cudnnSetRNNDescriptor)(internal, handle.c(), rnnDesc.c(), hiddenSize.c(), numLayers.c(), dropoutDesc.c(), inputMode.c(), direction.c(), mode.c(), algo.c(), dataType.c()); err != nil {
		return nil, err
	}

	return &RNN{
		internal:    internal,
		handle:      handle,
		rnnDesc:     rnnDesc,
		hiddenSize:  hiddenSize,
		numLayers:   numLayers,
		dropoutDesc: dropoutDesc,
		inputMode:   inputMode,
		direction:   direction,
		mode:        mode,
		algo:        algo,
		dataType:    dataType,
	}, nil
}

type PersistentRNNPlan struct {
	internal C.cudnnPersistentRNNPlan_t

	rnnDesc RNN
	plan    PersistentRNNPlan
}

func NewPersistentRNNPlan(rnnDesc RNN, plan PersistentRNNPlan) (*PersistentRNNPlan, error) {
	var internal C.cudnnPersistentRNNPlan_t
	if err := result(C.cudnnCreatePersistentRNNPlan(&internal)); err != nil {
		return nil, err
	}

	if err := result(C.cudnnSetPersistentRNNPlan)(internal, rnnDesc.c(), plan.c()); err != nil {
		return nil, err
	}

	return &PersistentRNNPlan{
		internal: internal,
		rnnDesc:  rnnDesc,
		plan:     plan,
	}, nil
}

type CTCLoss struct {
	internal C.cudnnCTCLossDescriptor_t

	ctcLossDesc CTCLoss
	compType    DataType
}

func NewCTCLoss(ctcLossDesc CTCLoss, compType DataType) (*CTCLoss, error) {
	var internal C.cudnnCTCLossDescriptor_t
	if err := result(C.cudnnCreateCTCLossDescriptor(&internal)); err != nil {
		return nil, err
	}

	if err := result(C.cudnnSetCTCLossDescriptor)(internal, ctcLossDesc.c(), compType.c()); err != nil {
		return nil, err
	}

	return &CTCLoss{
		internal:    internal,
		ctcLossDesc: ctcLossDesc,
		compType:    compType,
	}, nil
}

type Dropout struct {
	internal C.cudnnDropoutDescriptor_t

	dropoutDesc Dropout
	handle      Context
	dropout     float32
	states
	stateSizeInBytes
	seed uint64
}

func NewDropout(dropoutDesc Dropout, handle Context, dropout float32, states, stateSizeInBytes, seed uint64) (*Dropout, error) {
	var internal C.cudnnDropoutDescriptor_t
	if err := result(C.cudnnCreateDropoutDescriptor(&internal)); err != nil {
		return nil, err
	}

	if err := result(C.cudnnSetDropoutDescriptor)(internal, dropoutDesc.c(), handle.c(), dropout.c(), states.c(), stateSizeInBytes.c(), seed.c()); err != nil {
		return nil, err
	}

	return &Dropout{
		internal:         internal,
		dropoutDesc:      dropoutDesc,
		handle:           handle,
		dropout:          dropout,
		states:           states,
		stateSizeInBytes: stateSizeInBytes,
		seed:             seed,
	}, nil
}

type Activation struct {
	internal C.cudnnActivationDescriptor_t

	activationDesc Activation
	mode           ActivationMode
	reluNanOpt     NanPropagation
	coef           float64
}

func NewActivation(activationDesc Activation, mode ActivationMode, reluNanOpt NanPropagation, coef float64) (*Activation, error) {
	var internal C.cudnnActivationDescriptor_t
	if err := result(C.cudnnCreateActivationDescriptor(&internal)); err != nil {
		return nil, err
	}

	if err := result(C.cudnnSetActivationDescriptor)(internal, activationDesc.c(), mode.c(), reluNanOpt.c(), coef.c()); err != nil {
		return nil, err
	}

	return &Activation{
		internal:       internal,
		activationDesc: activationDesc,
		mode:           mode,
		reluNanOpt:     reluNanOpt,
		coef:           coef,
	}, nil
}

type LRN struct {
	internal C.cudnnLRNDescriptor_t

	normDesc LRN
	lrnN     uint
	lrnAlpha float64
	lrnBeta  float64
	lrnK     float64
}

func NewLRN(normDesc LRN, lrnN uint, lrnAlpha float64, lrnBeta float64, lrnK float64) (*LRN, error) {
	var internal C.cudnnLRNDescriptor_t
	if err := result(C.cudnnCreateLRNDescriptor(&internal)); err != nil {
		return nil, err
	}

	if err := result(C.cudnnSetLRNDescriptor)(internal, normDesc.c(), lrnN.c(), lrnAlpha.c(), lrnBeta.c(), lrnK.c()); err != nil {
		return nil, err
	}

	return &LRN{
		internal: internal,
		normDesc: normDesc,
		lrnN:     lrnN,
		lrnAlpha: lrnAlpha,
		lrnBeta:  lrnBeta,
		lrnK:     lrnK,
	}, nil
}

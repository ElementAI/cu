package cudnn

/* Generated by gencudnn. DO NOT EDIT */

// #include <cudnn_v7.h>
import "C"
import (
	"unsafe"

	"github.com/pkg/errors"
)

// Pooling is a representation of cudnnPoolingDescriptor_t.
type Pooling struct {
	internal C.cudnnPoolingDescriptor_t

	mode              PoolingMode
	maxpoolingNanNopt NanPropagation
	shape             []int
	padding           []int
	strides           []int

	// cache output shapes
	outputShape []int
	outDims     int // the dims for which the output shape was requested
}

// NewPooling creates a new Pooling.
func NewPooling(mode PoolingMode, maxpoolingNanOpt NanPropagation, shape, strides, padding []int) (retVal *Pooling, err error) {
	var internal C.cudnnPoolingDescriptor_t
	if err = result(C.cudnnCreatePoolingDescriptor(&internal)); err != nil {
		return nil, err
	}

	// checks shapes and strides
	if len(shape) != len(strides) || len(strides) != len(padding) {
		return nil, errors.Errorf(shapeMismatch3, shape, strides, padding)
	}

	switch len(shape) {
	case 0:
		return nil, errors.Errorf("Cannot perform pooling with shape %v", shape)
	case 2:
		windowHeight, windowWidth := shape[0], shape[1]
		verticalPadding, horizontalPadding := padding[0], padding[1]
		verticalStride, horizontalStride := strides[0], strides[1]
		if err = result(C.cudnnSetPooling2dDescriptor(internal, mode.C(), maxpoolingNanOpt.C(), C.int(windowHeight), C.int(windowWidth), C.int(verticalPadding), C.int(horizontalPadding), C.int(verticalStride), C.int(horizontalStride))); err != nil {
			return nil, err
		}
	default:
		nbDims := len(shape)
		shapePtr := (*C.int)(unsafe.Pointer(&shape[0]))
		paddingPtr := (*C.int)(unsafe.Pointer(&padding[0]))
		stridePtr := (*C.int)(unsafe.Pointer(&strides[0]))
		if err = result(C.cudnnSetPoolingNdDescriptor(internal, mode.C(), maxpoolingNanOpt.C(), C.int(nbDims), shapePtr, paddingPtr, stridePtr)); err != nil {
			return nil, err
		}
	}

	return &Pooling{
		internal:          internal,
		mode:              mode,
		maxpoolingNanNopt: maxpoolingNanOpt,
		shape:             shape,
		padding:           padding,
		strides:           strides,
	}, nil
}

func (p *Pooling) Mode() PoolingMode                { return p.mode }
func (p *Pooling) MaxPoolingNaNOpt() NanPropagation { return p.maxpoolingNanNopt }

func (p *Pooling) Shape() []int {
	retVal := make([]int, len(p.shape))
	copy(retVal, p.shape)
	return retVal
}

func (p *Pooling) Padding() []int {
	retVal := make([]int, len(p.padding))
	copy(retVal, p.padding)
	return retVal
}

func (p *Pooling) Strides() []int {
	retVal := make([]int, len(p.strides))
	copy(retVal, p.strides)
	return retVal
}

func (p *Pooling) OutputShape(input *TensorDescriptor, dims int) (retVal []int, err error) {
	if p.outputShape != nil && dims == p.outDims {
		goto end
	}
	p.outDims = dims
	switch dims {
	case 0:
		return nil, errors.Errorf("Cannot work on dims of 0")
	case 2:
		p.outputShape = make([]int, 4)
		n := (*C.int)(unsafe.Pointer(&p.outputShape[0]))
		c := (*C.int)(unsafe.Pointer(&p.outputShape[1]))
		h := (*C.int)(unsafe.Pointer(&p.outputShape[2]))
		w := (*C.int)(unsafe.Pointer(&p.outputShape[3]))
		if err = result(C.cudnnGetPooling2dForwardOutputDim(p.internal, input.internal, n, c, h, w)); err != nil {
			return nil, err
		}

	default:
		p.outputShape = make([]int, dims)
		ptr := (*C.int)(unsafe.Pointer(&p.outputShape[0]))
		if err = result(C.cudnnGetPoolingNdForwardOutputDim(p.internal, input.internal, C.int(dims), ptr)); err != nil {
			return nil, err
		}
	}
end:
	retVal = make([]int, len(p.outputShape))
	copy(retVal, p.outputShape)
	return
}

// TODO: Getters for Pooling

func destroyPooling(obj *Pooling) { C.cudnnDestroyPoolingDescriptor(obj.internal) }
